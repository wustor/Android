### 栈跟队列
1. 设计一个有**getMin**功能的栈
2. 由两个栈组成的队列
3. 如何仅用递归函数和栈操作逆序一个栈
4. 猫狗队列
5. 用一个栈实现另一个栈的排序
6. 用栈来求解汉诺塔问题
7. 生成窗口最大值数组
8. 构造数组的MaxTree
9. 求最大子矩阵的大小
10. 最大值减去最小值小于或等于num的子数组数量


### 链表问题
1. 打印两个有序链表的公共部分
2. 在单链表和双链表中删除倒数第K个节点
3. 删除链表的中间节点和a/b处的节点
4. 反转单向跟双向链表
5. 反转部分单向链表
6. 环形单链表的约瑟夫问题
7. 判断一个链表是否为回文结构
8. 将单向链表按某值划分为左边小、中间相等、右边大的形式
9. 复制含有随机指针节点的链表
10. 两个单链表生成相加链表
11. 两个单链表相交的一系列问题
12. 将单链表的每K个节点之间逆序
13. 删除无序单链表中值重复出现的节点
14. 将搜索二叉树转换成双向链表
15. 单链表的选择排序
16. 一种怪异的节点删除方式
17. 向有序的环形单链表中插入新节点
18. 合并两个有序的单链表
19. 按照左右半区的方式重新组合单链表

### 二叉树
1. 分别用递归和非递归方式实现二叉树先序、中序和后序遍历
2. 打印二叉树的边界节点
3. 如何较为直观的打印二叉树
4. 二叉树的序列化和反序列化
5. 遍历二叉树的神级方法
6. 判断二叉树是否为平衡二叉树

### 递归思想
有递有归

#### 在归的过程中解决问题

```java
recursion(大规模)
{
     if (end_condition)
     {
          end;     
     }
     else
     {     //先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题
          recursion(小规模);     //go;
          solve;                //back;
     }
}


```



### 在递的过程中解决问题

```java
recursion(大规模)
{
     if (end_condition)
     {
          end;     
     }
     else
     {     //在将问题转换为子问题描述的每一步，都解决该步中剩余部分的问题。
          solve;                //back;
          recursion(小规模);     //go;
     }
}

```

### 在出口的时候解决问题

```java
    void permute() {
        if (end_condition) {
            solve;
            end;
        } else {
            permute();
        }
    }

```
